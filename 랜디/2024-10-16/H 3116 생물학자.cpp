//MLE 해결 방안을 찾다가 에디토리얼을 확인했다.
//내가 잘못 생각했던 것은 (1,2)이고 (2,3)일 때 원소들이 겹치면 안되므로 이 때의 처리를 Map으로 처리해야 한다는 것이었다.
//물론 이 방식이 틀린 것은 아니지만 그러지 않아도 된다. 
//왜냐하면 1에서 다른 박테리아간 교차 비교를 할 때, (1,2)와 (1,3)이 모두 걸리므로 제대로 처리된다.
//그러므로 기준 박테리아를 바꿀 때마다 배열을 초기화시켜서 사용해도 된다.
//초기화를 직접적으로 해버리면 TLE기에, 에디토리얼에서는 쿠키를 써서 이를 막는다고 하는데, 
//이런 처리 방법을 쿠키라고 부르기엔 좀 애매하지 않나 싶다.

/*
다음은 에디토리얼 기반 해설이다.
먼저 복잡하게 구현했던 두 박테리아가 교차하는 시간을 구하는 부분을 보완할 수 있다.

D1 두 박테리아간 이동 전 거리
D2 두 박테리아가 각각 한 칸씩 이동했을 때 사이 거리

공통적으로 두 박테리아간 거리를 구할 땐, max(abs(Ax-Bx), abs(Ay-By))를 사용할 수 있다.
박테리아가 8방향으로 이동할 수 있기에 이게 성립한다.

두 박테리아가 겹치는 시간을 T라고 정의했을 때, 다음의 식이 성립한다.
D1 = T * (D1-D2)
(D1-D2)는 한 번 이동할 때마다 두 박테리아끼리 가까워지는 거리를 뜻한다.
T번 이동했을 때, 처음 박테리아간 거리인 D1만큼 이동해야 둘이 만나므로 올바른 식이다.

그러므로 두 박테리아가 겹치는 시간 T는 다음과 같이 구할 수 있다.
T = D1 / (D1-D2)

T는 정수여야 하므로 모듈러 연산을 통해 체크해주고, D1<=D2이면 이동을 아무리 해도 거리가 줄어들지 않거나 점점 멀어진다는 의미이기에 따로 처리해줘야 한다.

근데 이렇게 구한 T는 박테리아간 거리가 줄어들었다가 늘어나는 경우 문제가 생긴다.
A는 2 방향으로 이동하고, B는 1 방향으로 이동한다고 가정할 때, 둘이 엇갈린다면 점점 가까워졌다가 멀어진다.
그러므로 다음의 조건문으로 실제로 T초 뒤에 두 박테리아가 같은 점에서 만나는지 검사를 해주어야 한다.
Ax+dx[Ad]*T==Bx+dx[Bd]*T && Ay+dy[Ad]*T==By+dy[Bd]*T

이렇게 T를 구했으면 그 이후는 간단한 처리를 통해 해결할 수 있다.
sol 1에서 Map을 사용해 답을 관리했다면, 이번엔 배열 두 개로 간단하게 관리할 수 있다.
처음에 Map을 사용해 답을 관리한 이유는 2중 for문으로 가능한 모든 겹치지 않는 쌍끼리 연산을 수행할 때, 이전 연산 결과가 다음 단계의 연산에 영향을 미칠 것이라 생각했는데 그렇지 않다. 
만약에 1을 시작으로 2 3 4 5 등의 박테리아와 연산을 실행했을 때, T=2를 만났다면, T=2인 다른 모든 쌍들은 1을 시작으로 한 연산 내에서 모두 찾을 수 있다.
그렇지만 연산을 시작할 박테리아가 바뀔때마다 배열을 초기화하는 것은 TLE를 일으킨다.
그렇기에 T초에 박테리아가 몇 마리 있던 때가 몇번 박테리아를 시작점으로 했을 때인지를 COOKIE 배열에 저장해두어서, 값이 현재 시작값과 같으면 ++을, 아니면 현재 시작값으로 갱신하고 초기값인 2를 넣어준다.
*/

#include <bits/stdc++.h>
using namespace std;
#define fastio cin.tie(NULL)->sync_with_stdio(false)
#define ll long long
#define tiii tuple<ll,ll,ll>

ll dy[] = {1, 1, 1, 0, -1, -1, -1, 0};
ll dx[] = {-1, 0, 1, 1, 1, 0, -1, -1};

//두 박테리아가 언제 교차하는지 반환 (교차 못차면 -1)
ll intersect(tiii A, tiii B){
   auto[Ax, Ay, Ad] = A;
   auto[Bx, By, Bd] = B;
   ll D1 = max(abs(Ax-Bx), abs(Ay-By));
   ll D2 = max(abs((Ax+dx[Ad]) - (Bx+dx[Bd])), abs((Ay+dy[Ad]) - (By+dy[Bd])));
   if(D1<=D2 || D1%(D1-D2)!=0) return -1;
   ll T = D1/(D1-D2);
   if(Ax+dx[Ad]*T==Bx+dx[Bd]*T && Ay+dy[Ad]*T==By+dy[Bd]*T) return T;
   return -1;
}

int main(){
   fastio;
   int N; cin>>N;
   vector<tiii> V(N);
   for(int i=0; i<N; i++){
      ll X,Y,D; cin>>X>>Y>>D; D--;
      V[i] = {X,Y,D};
   }
   
   vector<ll> cnt(200'0003, -1);
   vector<ll> COOKIE(200'0003, -1);
   ll Ans[2] = {0,0};

   for(int i=0; i<N; i++){
      for(int j=i+1; j<N; j++){
         //if(i==j) continue; 
         //j의 시작을 0으로 잡아도 되는데, 그렇게 하지 않아도 된다.
         //겹치는 쌍들은 알고리즘상 결과에 영향을 미치지 않기 때문이다.
         
         ll T = intersect(V[i], V[j]);
         if(T==-1) continue;
         
         if(COOKIE[T]!=i){
            COOKIE[T] = i;
            cnt[T] = 2;
         }
         else cnt[T]++;

         if(cnt[T]>=Ans[0]){
            if(cnt[T]==Ans[0]) Ans[1] = min(Ans[1], T);
            else Ans[1] = T;
            Ans[0] = cnt[T];
         }
      }
   }
   cout<<Ans[0]<<'\n'<<Ans[1];
   return 0;
}
